// Class PileOfCards for FinalProject
// Program PlayingCards by Ray Arias

class PileOfCards extends Shuffleable {

  // Default Constructor for Class PileOfCards
  PileOfCards() {
    super();
  }

  // Deep Copy Constructor for Class PileOfCards
  // Calls deep copy constructor of Class Shuffleable
  // which calls its deepClone(Shuffleable) method
  PileOfCards(PileOfCards copy) {
    super(copy);
  }

  // Takes PileOfCards instance and removes a random
  // number of cards from it and places them into
  // a new Shuffleable object that is returned
  @Override
  public Shuffleable cut() {
    Shuffleable result = new PileOfCards();
    
    // int rand is generated by Class Shuffleable's
    // static getRandomInt(int) : int method
    int rand = Shuffleable.getRandomInt(this.quantity);
    try {
      // Use rand to call this.cut(int) method
      result = this.cut(rand);
    } catch (NumberOutOfRangeException noor) {
      noor.printStackTrace();
    }
    return result;
  }
  
  // Takes PileOfCard instance and removes a given
  // number of cards (given by int location) and
  // places them into a new Shuffleable object
  // that is returned
  @Override
  public Shuffleable cut(int location) throws NumberOutOfRangeException {
  
    Shuffleable poc = new PileOfCards();
    if (location < 1) {
      throw new NumberOutOfRangeException("Value for int location (" + location
        + ") is nonpositive!");
    } else {
      
      // Beginning at given location take the card
      // from this location of the current PileOfCards
      // instance and make it the top card of the new
      // Shuffleable object and do this while i > 0
      // Note: First card taken from current instance
      // is at position N, second card taken is at
      // position N - 1, next one is at N - 2, and so
      // on, until the last one at position 1.
      for (int i = location; i > 0; i--) {
        try {
          poc.addCardToTop(this.takeNthCard(i));
        } catch (TakingFromEmptyPileException ep) {
          ep.printStackTrace();
        } catch (ReachingBeyondBottomOfPileException bbp) {
          bbp.printStackTrace();
        }
      }
    }
    return poc;
  }

  
  // This method takes the Cards from a
  // Shuffleable object places them in
  // bottom of a new Shuffleable object
  // object called uncut. Then all the
  // Cards in the current instance of
  // PileOfCards are added on top of
  // the uncut object. The current in-
  // stance is deepCloned from the
  // uncut object.
  @Override
  public void uncut(Shuffleable poc) {
    Shuffleable uncut = new PileOfCards();
    int q1 = poc.getQuantity();
    int q2 = this.getQuantity();
    
    for (int i = 0; i < q1; i++) {
      try {
        uncut.addCardToTop(poc.takeBottomCard());
      } catch (TakingFromEmptyPileException ep) {
      ep.printStackTrace();
      }
    }
    for (int i = 0; i < q2; i++) {
      try {
        uncut.addCardToTop(this.takeBottomCard());
      } catch (TakingFromEmptyPileException ep) {
        ep.printStackTrace();
      }
    }
    this.dispose();
    try {
      this.deepClone(uncut);
    } catch (NumberOutOfRangeException noor) {
      noor.printStackTrace();
    }
  }
  
  
  // This method takes a card from the bottom
  // of the current instance of PileOfCards,
  // places it at the top of a new Shuffleable
  // instance, then takes a card from the
  // bottom of the Shuffleable instance passed
  // in as a parameter, and places it at the
  // top of the new instance until the object
  // with fewer cards runs out. At this point,
  // the method just takes the remaining cards
  // from the bottom of the old instance with
  // the greater number of cards and places
  // one on the top of the new instance until
  // no more cards remain in the remaining old
  // instance. Thus, this method reproduces
  // virtually what occurs when two piles of
  // cards are physically shuffled downward
  // into one new pile of cards. The new
  // instance is then copied into the current
  // instance, using the deepClone(Shuffleable)
  // method in the Shuffleable superclass.
  @Override
  public void shuffleDown(Shuffleable poc) {

    Shuffleable shuffled = new PileOfCards();
    
    int q1 = this.quantity;
    int q2 = poc.quantity;
    int greatr, lesser;
  
    if (q1 > q2) {
      greatr = q1;
      lesser = q2;
    } else {
      greatr = q2;
      lesser = q1;
    }
  
    for (int i = 0; i < lesser; i++) {
      try {
        shuffled.addCardToTop(this.takeBottomCard());
        shuffled.addCardToTop(poc.takeBottomCard());
      } catch (TakingFromEmptyPileException ep) {
        ep.printStackTrace();
      }
    }
    for (int i = lesser; i < greatr; i++) {
      if (greatr == q1) {
        try {
          shuffled.addCardToTop(this.takeBottomCard());
        } catch (TakingFromEmptyPileException ep) {
          ep.printStackTrace();
        }
      } else { // (greatr == q2)
        try {
          shuffled.addCardToTop(poc.takeBottomCard());
        } catch (TakingFromEmptyPileException ep) {
          ep.printStackTrace();
        }
      }
    }
    this.dispose();
    try {
      this.deepClone(shuffled);
    } catch (NumberOutOfRangeException noor) {
      noor.printStackTrace();
    }
  }

  // This method works like
  // shuffleDown(Shuffleable) except that the
  // Card objects from both old instances are
  // placed into the new instance in exactly
  // the reverse order. Specifically, a card
  // from the top of the current instance of
  // PileOfCards is taken and placed at the
  // bottom of a new Shuffleable instance, then
  // another card is taken from the top of the
  // Shuffleable instance passed in as a
  // parameter, and placed at the bottom of
  // the new instance until the object with
  // fewer cards runs out. At this point, the
  // remaining cards are taken from the top of
  // the old instance with the greater number
  // of cards and placed at the bottom of the
  // new instance until no more cards remain in
  // the remaining old instance. This reproduces
  // virtually what occurs when two piles of
  // are physically shuffled upward into one new
  // pile. The new instance is then copied into
  // the current instance, using the 
  // deepClone(Shuffleable) method in the
  // Shuffleable superclass.
  @Override
  public void shuffleUp(Shuffleable poc) {
  
    Shuffleable shuffled = new PileOfCards();
    
    int q1 = this.quantity;
    int q2 = poc.quantity;
    int greatr, lesser;
  
    if (q1 >= q2) { 
      greatr = q1;
      lesser = q2;
    } else {
      greatr = q2;
      lesser = q1;
    }
 
    for (int i = 0; i < lesser; i++) {
   
      try {
        shuffled.addCardToBottom(this.takeTopCard());
        shuffled.addCardToBottom(poc.takeTopCard());
      } catch (TakingFromEmptyPileException ep) {
        ep.printStackTrace();
      }
    }
    for (int i = lesser; i < greatr; i++) {
      
      if (greatr == q1) {
   
        try {
          shuffled.addCardToBottom(this.takeTopCard());
        } catch (TakingFromEmptyPileException ep) {
          ep.printStackTrace();
        }
    
      } else { // (greatr == q2)
     
        try {
          shuffled.addCardToBottom(poc.takeTopCard());
        } catch (TakingFromEmptyPileException ep) {
          ep.printStackTrace();
        }
      }
    }

    this.dispose();
    try {
      this.deepClone(shuffled);
    } catch (NumberOutOfRangeException noor) {
      noor.printStackTrace();
    }
  }
  
  
  // This method iterates through the entire
  // current instance of PileOfCards and displays
  // each card in it.
  @Override
  public void show() {
    int p;
    int q = this.quantity;
    String format = "%2d: %s \n";
    
    for (int i = 0; i < q; i++) {
      p = i + 1;
      try {
        TextUI.dispf(format, p, takeTopCard().toString());
      } catch (TakingFromEmptyPileException ep) {
        ep.printStackTrace();
      }
    }
    TextUI.newln();
  }
  
}